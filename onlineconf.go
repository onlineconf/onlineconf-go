// Package onlineconf reads configuration files generated by OnlineConf.
//
// It opens indexed CDB files and maps them in the memory.
// If OnlineConf modifies them then they are automatically reopened.
package onlineconf

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"path"
	"reflect"
	"strconv"
	"strings"
	"sync"

	"github.com/colinmarc/cdb"
	"github.com/fsnotify/fsnotify"
	"github.com/my-mail-ru/exp/mmap"
)

var ErrFormatIsNotJSON = errors.New("format is not JSON")

var configDir = "/usr/local/etc/onlineconf"

var watcherLock sync.Mutex
var watcher *fsnotify.Watcher

func init() {
	modules.byName = make(map[string]*Module)
	modules.byFile = make(map[string]*Module)
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
	log.SetOutput(w)
}

type Module struct {
	mutex       sync.RWMutex
	name        string
	filename    string
	mmappedFile *mmap.ReaderAt
	cdb         *cdb.CDB
	cache       map[string][]interface{}
	cacheMutex  sync.RWMutex
}

func newModule(name string) *Module {
	filename := path.Join(configDir, name+".cdb")

	ocModule := &Module{name: name, filename: filename}
	err := ocModule.reopen()
	if err != nil {
		panic(err)
	}

	initWatcher()

	return ocModule
}

func initWatcher() {
	watcherLock.Lock()
	defer watcherLock.Unlock()

	if watcher != nil {
		return
	}

	var err error
	watcher, err = fsnotify.NewWatcher()
	if err != nil {
		panic(err)
	}

	err = watcher.Add(configDir)
	if err != nil {
		panic(err)
	}

	go func() {
		for {
			select {
			case ev := <-watcher.Events:
				//log.Println("fsnotify event:", ev)

				if (ev.Op&fsnotify.Create == fsnotify.Create) || (ev.Op&fsnotify.Write == fsnotify.Write) {
					modules.Lock()
					module, ok := modules.byFile[ev.Name]
					modules.Unlock()

					if ok {
						module.reopen()
					}
				}

			case err := <-watcher.Errors:
				log.Printf("Watch %v error: %v\n", configDir, err)
			}
		}
	}()
}

func (m *Module) reopen() error {
	log.Printf("Reopen %s\n", m.filename)
	m.mutex.Lock()
	defer m.mutex.Unlock()

	oldMmappedFile := m.mmappedFile

	mmappedFile, err := mmap.Open(m.filename)
	if err != nil {
		return fmt.Errorf("mmap Open module: %w", err)
	}

	cdb, err := cdb.New(mmappedFile, nil)
	if err != nil {
		mmappedFile.Close()
		return err
	}

	m.cdb = cdb

	if oldMmappedFile != nil {
		oldMmappedFile.Close()
	}

	m.cacheMutex.Lock()
	m.cache = map[string][]interface{}{}
	m.cacheMutex.Unlock()

	return nil
}

func (m *Module) get(path string) (byte, []byte) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	data, err := m.cdb.Get([]byte(path))
	if err != nil || len(data) == 0 {
		if err != nil {
			log.Printf("Get %v:%v error: %v", m.filename, path, err)
		}
		return 0, data
	}
	return data[0], data[1:]
}

// GetStringIfExists reads a string value of a named parameter from the module.
// It returns the boolean true if the parameter exists and is a string.
// In the other case it returns the boolean false and an empty string.
func (m *Module) GetStringIfExists(path string) (string, bool) {
	format, data := m.get(path)
	switch format {
	case 0:
		return "", false
	case 's':
		return string(data), true
	default:
		log.Printf("%s:%s: format is not string\n", m.name, path)
		return "", false
	}
}

// GetIntIfExists reads an integer value of a named parameter from the module.
// It returns this value and the boolean true if the parameter exists and is an integer.
// In the other case it returns the boolean false and 0.
func (m *Module) GetIntIfExists(path string) (int, bool) {
	str, ok := m.GetStringIfExists(path)
	if !ok {
		return 0, false
	}

	i, err := strconv.Atoi(str)
	if err != nil {
		log.Printf("%s:%s: value is not an integer: %s\n", m.name, path, str)
		return 0, false
	}

	return i, true
}

// GetBoolIfExists reads an integer value of a named parameter from the module.
// It returns this value and the boolean true if the parameter exists and is an bool.
// In the other case it returns the boolean false and 0.
func (m *Module) GetBoolIfExists(path string) (bool, bool) {
	str, ok := m.GetStringIfExists(path)
	if !ok {
		return false, false
	}

	if len(str) == 0 || str == "0" {
		return false, true
	}

	return true, true
}

// GetString reads a string value of a named parameter from the module.
// It returns this value if the parameter exists and is a string.
// In the other case it panics unless default value is provided in
// the second argument.
func (m *Module) GetString(path string, d ...string) string {
	if val, ok := m.GetStringIfExists(path); ok {
		return val
	} else if len(d) > 0 {
		return d[0]
	} else {
		panic(fmt.Sprintf("%s:%s key not exists and default not found", m.name, path))
	}
}

// GetInt reads an integer value of a named parameter from the module.
// It returns this value if the parameter exists and is an integer.
// In the other case it panics unless default value is provided in
// the second argument.
func (m *Module) GetInt(path string, d ...int) int {
	if val, ok := m.GetIntIfExists(path); ok {
		return val
	} else if len(d) > 0 {
		return d[0]
	} else {
		panic(fmt.Sprintf("%s:%s key not exists and default not found", m.name, path))
	}
}

// GetBool reads an bool value of a named parameter from the module.
// It returns this value if the parameter exists and is a bool.
// In the other case it panics unless default value is provided in
// the second argument.
func (m *Module) GetBool(path string, d ...bool) bool {
	if val, ok := m.GetBoolIfExists(path); ok {
		return val
	} else if len(d) > 0 {
		return d[0]
	} else {
		panic(fmt.Sprintf("%s:%s key not exists and default not found", m.name, path))
	}
}

// GetStrings reads a []string value of a named parameter from the module.
// It returns this value if the parameter exists and is a comma-separated
// string or JSON array.
// In the other case it returns a default value provided in the second
// argument.
func (m *Module) GetStrings(path string, defaultValue []string) []string {
	var value []string
	rv := reflect.ValueOf(&value).Elem()
	if m.getCache(path, rv) {
		return value
	}

	format, data := m.get(path)
	switch format {
	case 0:
		return defaultValue
	case 's':
		untrimmed := strings.Split(string(data), ",")
		value = make([]string, 0, len(untrimmed))
		for _, item := range untrimmed {
			if trimmed := strings.TrimSpace(item); trimmed != "" {
				value = append(value, trimmed)
			}
		}
		m.setCache(path, rv)
		return value
	case 'j':
		err := json.Unmarshal(data, &value)
		if err != nil {
			log.Printf("%s:%s: failed to unmarshal JSON: %s", m.name, path, err)
			return defaultValue
		}
		m.setCache(path, rv)
		return value
	default:
		log.Printf("%s:%s: unexpected format\n", m.name, path)
		return defaultValue
	}
}

// GetStruct reads a structured value of a named parameter from the module.
// It stores this value in the value pointed by the value argument
// and returns true if the parameter exists and was unmarshaled successfully.
// In the case of error or if the parameter is not exists, the method doesn't
// touch the value argument, so you can safely pass a default value as the value
// argument and completely ignore return values of this method.
// A value is unmarshaled from JSON using json.Unmarshal and is cached internally
// until the configuration is updated, so be careful to not modify values returned by
// a reference.
// Experimental: this method can be modified or removed without any notice.
func (m *Module) GetStruct(path string, value interface{}) (bool, error) {
	rv := reflect.ValueOf(value)
	if rv.Kind() != reflect.Ptr {
		if rv.IsValid() {
			log.Printf("%s: GetStruct(%q, non-pointer %s): invalid argument", m.name, path, rv.Type())
		} else {
			log.Printf("%s: GetStruct(%q, nil): invalid argument", m.name, path)
		}
		return false, &json.InvalidUnmarshalError{Type: reflect.TypeOf(value)}
	} else if rv.IsNil() {
		log.Printf("%s: GetStruct(%q, nil %s): invalid argument", m.name, path, rv.Type())
		return false, &json.InvalidUnmarshalError{Type: reflect.TypeOf(value)}
	}
	rv = rv.Elem()

	if m.getCache(path, rv) {
		return true, nil
	}

	format, data := m.get(path)
	switch format {
	case 0:
		return false, nil
	case 'j':
		val := reflect.New(rv.Type())
		err := json.Unmarshal(data, val.Interface())
		if err != nil {
			log.Printf("%s:%s: failed to unmarshal JSON: %s", m.name, path, err)
			return false, err
		}
		rv.Set(val.Elem())
		m.setCache(path, rv)
		return true, nil
	default:
		err := ErrFormatIsNotJSON
		log.Printf("%s:%s: %s\n", m.name, path, err)
		return false, err
	}
}

func (m *Module) getCache(path string, rv reflect.Value) bool {
	m.cacheMutex.RLock()
	defer m.cacheMutex.RUnlock()
	for _, cv := range m.cache[path] {
		rcv := reflect.ValueOf(cv)
		if rcv.Type() == rv.Type() {
			rv.Set(rcv)
			return true
		}
	}
	return false
}

func (m *Module) setCache(path string, rv reflect.Value) {
	m.cacheMutex.Lock()
	defer m.cacheMutex.Unlock()
	values := m.cache[path]
	for i := range values {
		if reflect.TypeOf(values[i]) == rv.Type() {
			values[i] = rv.Interface()
			return
		}
	}
	m.cache[path] = append(values, rv.Interface())
}

var modules struct {
	sync.Mutex
	byName map[string]*Module
	byFile map[string]*Module
}

// GetModule returns a named module.
func GetModule(name string) *Module {
	modules.Lock()
	defer modules.Unlock()

	if module, ok := modules.byName[name]; ok {
		return module
	}

	module := newModule(name)

	modules.byName[module.name] = module
	modules.byFile[module.filename] = module

	return module
}

// Initialize sets config directory for onlineconf modules.
// Default value is "/usr/local/etc/onlineconf"
func Initialize(newConfigDir string) {
	watcherLock.Lock()
	defer watcherLock.Unlock()
	if watcher != nil {
		panic("Initialize must be called before any onlineconf module was created")
	}

	configDir = newConfigDir
}

var tree struct {
	sync.Mutex
	module *Module
}

func getTree() *Module {
	if tree.module != nil {
		return tree.module
	}

	tree.Lock()
	defer tree.Unlock()

	if tree.module != nil {
		return tree.module
	}

	tree.module = GetModule("TREE")
	return tree.module
}

// GetStringIfExists reads a string value of a named parameter from the module "TREE".
// It returns the boolean true if the parameter exists and is a string.
// In the other case it returns the boolean false and an empty string.
func GetStringIfExists(path string) (string, bool) {
	return getTree().GetStringIfExists(path)
}

// GetIntIfExists reads an integer value of a named parameter from the module "TREE".
// It returns this value and the boolean true if the parameter exists and is an integer.
// In the other case it returns the boolean false and 0.
func GetIntIfExists(path string) (int, bool) {
	return getTree().GetIntIfExists(path)
}

// GetBoolIfExists reads an bool value of a named parameter from the module "TREE".
// It returns this value and the boolean true if the parameter exists and is a bool.
// In the other case it returns the boolean false and 0.
func GetBoolIfExists(path string) (bool, bool) {
	return getTree().GetBoolIfExists(path)
}

// GetString reads a string value of a named parameter from the module "TREE".
// It returns this value if the parameter exists and is a string.
// In the other case it panics unless default value is provided in
// the second argument.
func GetString(path string, d ...string) string {
	return getTree().GetString(path, d...)
}

// GetInt reads an integer value of a named parameter from the module "TREE".
// It returns this value if the parameter exists and is an integer.
// In the other case it panics unless default value is provided in
// the second argument.
func GetInt(path string, d ...int) int {
	return getTree().GetInt(path, d...)
}

// GetBool reads an bool value of a named parameter from the module "TREE".
// It returns this value if the parameter exists and is a bool.
// In the other case it panics unless default value is provided in
// the second argument.
func GetBool(path string, d ...bool) bool {
	return getTree().GetBool(path, d...)
}

// GetStrings reads a []string value of a named parameter from the module "TREE".
// It returns this value if the parameter exists and is a comma-separated string
// or JSON array.
// In the other case it returns a default value provided in the second argument.
func GetStrings(path string, defaultValue []string) []string {
	return getTree().GetStrings(path, defaultValue)
}

// GetStruct reads a structured value of a named parameter from the module "TREE".
// It stores this value in the value pointed by the value argument
// and returns true if the parameter exists and was unmarshaled successfully.
// In the case of error or if the parameter is not exists, the function doesn't
// touch the value argument, so you can safely pass a default value as the value
// argument and completely ignore return values of this function.
// A value is unmarshaled from JSON using json.Unmarshal and is cached internally
// until the configuration is updated, so be careful to not modify values returned by
// a reference.
// Experimental: this function can be modified or removed without any notice.
func GetStruct(path string, value interface{}) (bool, error) {
	return getTree().GetStruct(path, value)
}
